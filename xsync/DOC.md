<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# xsync

```go
import "github.com/fufuok/cache/xsync"
```

## Index

- [func ToPlainMap\[K comparable, V any\]\(m \*Map\[K, V\]\) map\[K\]V](<#ToPlainMap>)
- [func WithGrowOnly\(\) func\(\*MapConfig\)](<#WithGrowOnly>)
- [func WithPresize\(sizeHint int\) func\(\*MapConfig\)](<#WithPresize>)
- [func WithSerialResize\(\) func\(\*MapConfig\)](<#WithSerialResize>)
- [type ComputeOp](<#ComputeOp>)
- [type Counter](<#Counter>)
  - [func NewCounter\(\) \*Counter](<#NewCounter>)
  - [func \(c \*Counter\) Add\(delta int64\)](<#Counter.Add>)
  - [func \(c \*Counter\) Dec\(\)](<#Counter.Dec>)
  - [func \(c \*Counter\) Inc\(\)](<#Counter.Inc>)
  - [func \(c \*Counter\) Reset\(\)](<#Counter.Reset>)
  - [func \(c \*Counter\) Value\(\) int64](<#Counter.Value>)
- [type MPMCQueue](<#MPMCQueue>)
  - [func NewMPMCQueue\[I any\]\(capacity int\) \*MPMCQueue\[I\]](<#NewMPMCQueue>)
  - [func NewMPMCQueueOf\[I any\]\(capacity int\) \*MPMCQueue\[I\]](<#NewMPMCQueueOf>)
  - [func \(q \*MPMCQueue\[I\]\) TryDequeue\(\) \(item I, ok bool\)](<#MPMCQueue[I].TryDequeue>)
  - [func \(q \*MPMCQueue\[I\]\) TryEnqueue\(item I\) bool](<#MPMCQueue[I].TryEnqueue>)
- [type MPMCQueueOf](<#MPMCQueueOf>)
- [type Map](<#Map>)
  - [func NewMap\[K comparable, V any\]\(options ...func\(\*MapConfig\)\) \*Map\[K, V\]](<#NewMap>)
  - [func NewMapOf\[K comparable, V any\]\(options ...func\(\*MapConfig\)\) \*Map\[K, V\]](<#NewMapOf>)
  - [func \(m \*Map\[K, V\]\) Clear\(\)](<#Map[K, V].Clear>)
  - [func \(m \*Map\[K, V\]\) Compute\(key K, valueFn func\(oldValue V, loaded bool\) \(newValue V, op ComputeOp\)\) \(actual V, ok bool\)](<#Map[K, V].Compute>)
  - [func \(m \*Map\[K, V\]\) Delete\(key K\)](<#Map[K, V].Delete>)
  - [func \(m \*Map\[K, V\]\) Load\(key K\) \(value V, ok bool\)](<#Map[K, V].Load>)
  - [func \(m \*Map\[K, V\]\) LoadAndDelete\(key K\) \(value V, loaded bool\)](<#Map[K, V].LoadAndDelete>)
  - [func \(m \*Map\[K, V\]\) LoadAndStore\(key K, value V\) \(actual V, loaded bool\)](<#Map[K, V].LoadAndStore>)
  - [func \(m \*Map\[K, V\]\) LoadOrCompute\(key K, valueFn func\(\) \(newValue V, cancel bool\)\) \(value V, loaded bool\)](<#Map[K, V].LoadOrCompute>)
  - [func \(m \*Map\[K, V\]\) LoadOrStore\(key K, value V\) \(actual V, loaded bool\)](<#Map[K, V].LoadOrStore>)
  - [func \(m \*Map\[K, V\]\) Range\(f func\(key K, value V\) bool\)](<#Map[K, V].Range>)
  - [func \(m \*Map\[K, V\]\) Size\(\) int](<#Map[K, V].Size>)
  - [func \(m \*Map\[K, V\]\) Stats\(\) MapStats](<#Map[K, V].Stats>)
  - [func \(m \*Map\[K, V\]\) Store\(key K, value V\)](<#Map[K, V].Store>)
- [type MapConfig](<#MapConfig>)
- [type MapOf](<#MapOf>)
- [type MapStats](<#MapStats>)
  - [func \(s \*MapStats\) ToString\(\) string](<#MapStats.ToString>)
- [type RBMutex](<#RBMutex>)
  - [func NewRBMutex\(\) \*RBMutex](<#NewRBMutex>)
  - [func \(mu \*RBMutex\) Lock\(\)](<#RBMutex.Lock>)
  - [func \(mu \*RBMutex\) RLock\(\) \*RToken](<#RBMutex.RLock>)
  - [func \(mu \*RBMutex\) RUnlock\(t \*RToken\)](<#RBMutex.RUnlock>)
  - [func \(mu \*RBMutex\) TryLock\(\) bool](<#RBMutex.TryLock>)
  - [func \(mu \*RBMutex\) TryRLock\(\) \(bool, \*RToken\)](<#RBMutex.TryRLock>)
  - [func \(mu \*RBMutex\) Unlock\(\)](<#RBMutex.Unlock>)
- [type RToken](<#RToken>)
- [type SPSCQueue](<#SPSCQueue>)
  - [func NewSPSCQueue\[I any\]\(capacity int\) \*SPSCQueue\[I\]](<#NewSPSCQueue>)
  - [func NewSPSCQueueOf\[I any\]\(capacity int\) \*SPSCQueue\[I\]](<#NewSPSCQueueOf>)
  - [func \(q \*SPSCQueue\[I\]\) TryDequeue\(\) \(item I, ok bool\)](<#SPSCQueue[I].TryDequeue>)
  - [func \(q \*SPSCQueue\[I\]\) TryEnqueue\(item I\) bool](<#SPSCQueue[I].TryEnqueue>)
- [type SPSCQueueOf](<#SPSCQueueOf>)
- [type UMPSCQueue](<#UMPSCQueue>)
  - [func NewUMPSCQueue\[T any\]\(\) \*UMPSCQueue\[T\]](<#NewUMPSCQueue>)
  - [func \(q \*UMPSCQueue\[T\]\) Dequeue\(\) T](<#UMPSCQueue[T].Dequeue>)
  - [func \(q \*UMPSCQueue\[T\]\) Enqueue\(value T\)](<#UMPSCQueue[T].Enqueue>)


<a name="ToPlainMap"></a>
## func [ToPlainMap](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L238>)

```go
func ToPlainMap[K comparable, V any](m *Map[K, V]) map[K]V
```

ToPlainMap returns a native map with a copy of xsync Map's contents. The copied xsync Map should not be modified while this call is made. If the copied Map is modified, the copying behavior is the same as in the Range method.

<a name="WithGrowOnly"></a>
## func [WithGrowOnly](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L167>)

```go
func WithGrowOnly() func(*MapConfig)
```

WithGrowOnly configures new Map instance to be grow\-only. This means that the underlying hash table grows in capacity when new keys are added, but does not shrink when keys are deleted. The only exception to this rule is the Clear method which shrinks the hash table back to the initial capacity.

<a name="WithPresize"></a>
## func [WithPresize](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L156>)

```go
func WithPresize(sizeHint int) func(*MapConfig)
```

WithPresize configures new Map instance with capacity enough to hold sizeHint entries. The capacity is treated as the minimal capacity meaning that the underlying hash table will never shrink to a smaller capacity. If sizeHint is zero or negative, the value is ignored.

<a name="WithSerialResize"></a>
## func [WithSerialResize](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L177>)

```go
func WithSerialResize() func(*MapConfig)
```

WithSerialResize enables serial resizing mode, matching the behavior of older versions. With this setting, Map will no longer spawn additional goroutines when resizing. Use in resource\-constrained environments, while parallel resizing \(default\) provides higher throughput.

<a name="ComputeOp"></a>
## type [ComputeOp](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L48>)



```go
type ComputeOp int
```

<a name="CancelOp"></a>

```go
const (
    // CancelOp signals to Compute to not do anything as a result
    // of executing the lambda. If the entry was not present in
    // the map, nothing happens, and if it was present, the
    // returned value is ignored.
    CancelOp ComputeOp = iota
    // UpdateOp signals to Compute to update the entry to the
    // value returned by the lambda, creating it if necessary.
    UpdateOp
    // DeleteOp signals to Compute to always delete the entry
    // from the map.
    DeleteOp
)
```

<a name="Counter"></a>
## type [Counter](<https://github.com/fufuok/cache/blob/master/xsync/counter.go#L29-L32>)

A Counter is a striped int64 counter.

Should be preferred over a single atomically updated int64 counter in high contention scenarios.

A Counter must not be copied after first use.

```go
type Counter struct {
    // contains filtered or unexported fields
}
```

<a name="NewCounter"></a>
### func [NewCounter](<https://github.com/fufuok/cache/blob/master/xsync/counter.go#L41>)

```go
func NewCounter() *Counter
```

NewCounter creates a new Counter instance.

<a name="Counter.Add"></a>
### func \(\*Counter\) [Add](<https://github.com/fufuok/cache/blob/master/xsync/counter.go#L61>)

```go
func (c *Counter) Add(delta int64)
```

Add adds the delta to the counter.

<a name="Counter.Dec"></a>
### func \(\*Counter\) [Dec](<https://github.com/fufuok/cache/blob/master/xsync/counter.go#L56>)

```go
func (c *Counter) Dec()
```

Dec decrements the counter by 1.

<a name="Counter.Inc"></a>
### func \(\*Counter\) [Inc](<https://github.com/fufuok/cache/blob/master/xsync/counter.go#L51>)

```go
func (c *Counter) Inc()
```

Inc increments the counter by 1.

<a name="Counter.Reset"></a>
### func \(\*Counter\) [Reset](<https://github.com/fufuok/cache/blob/master/xsync/counter.go#L94>)

```go
func (c *Counter) Reset()
```

Reset resets the counter to zero. This method should only be used when it is known that there are no concurrent modifications of the counter.

<a name="Counter.Value"></a>
### func \(\*Counter\) [Value](<https://github.com/fufuok/cache/blob/master/xsync/counter.go#L82>)

```go
func (c *Counter) Value() int64
```

Value returns the current counter value. The returned value may not include all of the latest operations in presence of concurrent modifications of the counter.

<a name="MPMCQueue"></a>
## type [MPMCQueue](<https://github.com/fufuok/cache/blob/master/xsync/mpmcqueue.go#L19-L27>)

A MPMCQueue is a bounded multi\-producer multi\-consumer concurrent queue.

MPMCQueue instances must be created with NewMPMCQueue function. A MPMCQueue must not be copied after first use.

Based on the data structure from the following C\+\+ library: https://github.com/rigtorp/MPMCQueue

```go
type MPMCQueue[I any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewMPMCQueue"></a>
### func [NewMPMCQueue](<https://github.com/fufuok/cache/blob/master/xsync/mpmcqueue.go#L54>)

```go
func NewMPMCQueue[I any](capacity int) *MPMCQueue[I]
```

NewMPMCQueue creates a new MPMCQueue instance with the given capacity.

<a name="NewMPMCQueueOf"></a>
### func [NewMPMCQueueOf](<https://github.com/fufuok/cache/blob/master/xsync/mpmcqueue.go#L48>)

```go
func NewMPMCQueueOf[I any](capacity int) *MPMCQueue[I]
```

Deprecated: use [NewMPMCQueue](<#NewMPMCQueue>).

<a name="MPMCQueue[I].TryDequeue"></a>
### func \(\*MPMCQueue\[I\]\) [TryDequeue](<https://github.com/fufuok/cache/blob/master/xsync/mpmcqueue.go#L84>)

```go
func (q *MPMCQueue[I]) TryDequeue() (item I, ok bool)
```

TryDequeue retrieves and removes the item from the head of the queue. Does not block and returns immediately. The ok result indicates that the queue isn't empty and an item was retrieved.

<a name="MPMCQueue[I].TryEnqueue"></a>
### func \(\*MPMCQueue\[I\]\) [TryEnqueue](<https://github.com/fufuok/cache/blob/master/xsync/mpmcqueue.go#L67>)

```go
func (q *MPMCQueue[I]) TryEnqueue(item I) bool
```

TryEnqueue inserts the given item into the queue. Does not block and returns immediately. The result indicates that the queue isn't full and the item was inserted.

<a name="MPMCQueueOf"></a>
## type [MPMCQueueOf](<https://github.com/fufuok/cache/blob/master/xsync/mpmcqueue.go#L9>)

Deprecated: use [MPMCQueue](<#MPMCQueue>).

```go
type MPMCQueueOf[I any] = MPMCQueue[I]
```

<a name="Map"></a>
## type [Map](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L96-L106>)

Map is like a Go map\[K\]V but is safe for concurrent use by multiple goroutines without additional locking or coordination. It follows the interface of sync.Map with a number of valuable extensions like Compute or Size.

A Map must not be copied after first use.

Map uses a modified version of Cache\-Line Hash Table \(CLHT\) data structure: https://github.com/LPD-EPFL/CLHT

CLHT is built around idea to organize the hash table in cache\-line\-sized buckets, so that on all modern CPUs update operations complete with at most one cache\-line transfer. Also, Get operations involve no write to memory, as well as no mutexes or any other sort of locks. Due to this design, in all considered scenarios Map outperforms sync.Map.

Map also borrows ideas from Java's j.u.c.ConcurrentHashMap \(immutable K/V pair structs instead of atomic snapshots\) and C\+\+'s absl::flat\_hash\_map \(meta memory and SWAR\-based lookups\).

```go
type Map[K comparable, V any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewMap"></a>
### func [NewMap](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L190>)

```go
func NewMap[K comparable, V any](options ...func(*MapConfig)) *Map[K, V]
```

NewMap creates a new Map instance configured with the given options.

<a name="NewMapOf"></a>
### func [NewMapOf](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L184>)

```go
func NewMapOf[K comparable, V any](options ...func(*MapConfig)) *Map[K, V]
```

Deprecated: use [NewMap](<#NewMap>).

<a name="Map[K, V].Clear"></a>
### func \(\*Map\[K, V\]\) [Clear](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L780>)

```go
func (m *Map[K, V]) Clear()
```

Clear deletes all keys and values currently stored in the map.

<a name="Map[K, V].Compute"></a>
### func \(\*Map\[K, V\]\) [Compute](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L377-L380>)

```go
func (m *Map[K, V]) Compute(key K, valueFn func(oldValue V, loaded bool) (newValue V, op ComputeOp)) (actual V, ok bool)
```

Compute either sets the computed new value for the key, deletes the value for the key, or does nothing, based on the returned [ComputeOp](<#ComputeOp>). When the op returned by valueFn is [UpdateOp](<#CancelOp>), the value is updated to the new value. If it is [DeleteOp](<#CancelOp>), the entry is removed from the map altogether. And finally, if the op is [CancelOp](<#CancelOp>) then the entry is left as\-is. In other words, if it did not already exist, it is not created, and if it did exist, it is not updated. This is useful to synchronously execute some operation on the value without incurring the cost of updating the map every time. The ok result indicates whether the entry is present in the map after the compute operation. The actual result contains the value of the map if a corresponding entry is present, or the zero value otherwise. See the example for a few use cases.

This call locks a hash table bucket while the compute function is executed. It means that modifications on other entries in the bucket will be blocked until the valueFn executes. Consider this when the function includes long\-running operations.

<a name="Map[K, V].Delete"></a>
### func \(\*Map\[K, V\]\) [Delete](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L399>)

```go
func (m *Map[K, V]) Delete(key K)
```

Delete deletes the value for a key.

<a name="Map[K, V].Load"></a>
### func \(\*Map\[K, V\]\) [Load](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L252>)

```go
func (m *Map[K, V]) Load(key K) (value V, ok bool)
```

Load returns the value stored in the map for a key, or zero value of type V if no value is present. The ok result indicates whether value was found in the map.

<a name="Map[K, V].LoadAndDelete"></a>
### func \(\*Map\[K, V\]\) [LoadAndDelete](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L387>)

```go
func (m *Map[K, V]) LoadAndDelete(key K) (value V, loaded bool)
```

LoadAndDelete deletes the value for a key, returning the previous value if any. The loaded result reports whether the key was present.

<a name="Map[K, V].LoadAndStore"></a>
### func \(\*Map\[K, V\]\) [LoadAndStore](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L313>)

```go
func (m *Map[K, V]) LoadAndStore(key K, value V) (actual V, loaded bool)
```

LoadAndStore returns the existing value for the key if present, while setting the new value for the key. It stores the new value and returns the existing one, if present. The loaded result is true if the existing value was loaded, false otherwise.

<a name="Map[K, V].LoadOrCompute"></a>
### func \(\*Map\[K, V\]\) [LoadOrCompute](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L336-L339>)

```go
func (m *Map[K, V]) LoadOrCompute(key K, valueFn func() (newValue V, cancel bool)) (value V, loaded bool)
```

LoadOrCompute returns the existing value for the key if present. Otherwise, it tries to compute the value using the provided function and, if successful, stores and returns the computed value. The loaded result is true if the value was loaded, or false if computed. If valueFn returns true as the cancel value, the computation is cancelled and the zero value for type V is returned.

This call locks a hash table bucket while the compute function is executed. It means that modifications on other entries in the bucket will be blocked until the valueFn executes. Consider this when the function includes long\-running operations.

<a name="Map[K, V].LoadOrStore"></a>
### func \(\*Map\[K, V\]\) [LoadOrStore](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L294>)

```go
func (m *Map[K, V]) LoadOrStore(key K, value V) (actual V, loaded bool)
```

LoadOrStore returns the existing value for the key if present. Otherwise, it stores and returns the given value. The loaded result is true if the value was loaded, false if stored.

<a name="Map[K, V].Range"></a>
### func \(\*Map\[K, V\]\) [Range](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L743>)

```go
func (m *Map[K, V]) Range(f func(key K, value V) bool)
```

Range calls f sequentially for each key and value present in the map. If f returns false, range stops the iteration.

Range does not necessarily correspond to any consistent snapshot of the Map's contents: no key will be visited more than once, but if the value for any key is stored or deleted concurrently, Range may reflect any mapping for that key from any point during the Range call.

It is safe to modify the map while iterating it, including entry creation, modification and deletion. However, the concurrent modification rule apply, i.e. the changes may be not reflected in the subsequently iterated entries.

<a name="Map[K, V].Size"></a>
### func \(\*Map\[K, V\]\) [Size](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L785>)

```go
func (m *Map[K, V]) Size() int
```

Size returns current size of the map.

<a name="Map[K, V].Stats"></a>
### func \(\*Map\[K, V\]\) [Stats](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L899>)

```go
func (m *Map[K, V]) Stats() MapStats
```

Stats returns statistics for the Map. Just like other map methods, this one is thread\-safe. Yet it's an O\(N\) operation, so it should be used only for diagnostics or debugging purposes.

<a name="Map[K, V].Store"></a>
### func \(\*Map\[K, V\]\) [Store](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L280>)

```go
func (m *Map[K, V]) Store(key K, value V)
```

Store sets the value for a key.

<a name="MapConfig"></a>
## type [MapConfig](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L145-L149>)

MapConfig defines configurable Map options.

```go
type MapConfig struct {
    // contains filtered or unexported fields
}
```

<a name="MapOf"></a>
## type [MapOf](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L73>)

Deprecated: use [Map](<#Map>)

```go
type MapOf[K comparable, V any] = Map[K, V]
```

<details><summary>Example (#ompute)</summary>
<p>



```go
package main

import (
	"errors"
	"fmt"

	"github.com/fufuok/cache/xsync"
)

func main() {
	counts := xsync.NewMap[int, int]()

	// Store a new value.
	v, ok := counts.Compute(42, func(oldValue int, loaded bool) (newValue int, op xsync.ComputeOp) {
		// loaded is false here.
		newValue = 42
		op = xsync.UpdateOp
		return
	})
	// v: 42, ok: true
	fmt.Printf("v: %v, ok: %v\n", v, ok)

	// Update an existing value.
	v, ok = counts.Compute(42, func(oldValue int, loaded bool) (newValue int, op xsync.ComputeOp) {
		// loaded is true here.
		newValue = oldValue + 42
		op = xsync.UpdateOp
		return
	})
	// v: 84, ok: true
	fmt.Printf("v: %v, ok: %v\n", v, ok)

	// Set a new value or keep the old value conditionally.
	var oldVal int
	minVal := 63
	v, ok = counts.Compute(42, func(oldValue int, loaded bool) (newValue int, op xsync.ComputeOp) {
		oldVal = oldValue
		if !loaded || oldValue < minVal {
			newValue = minVal
			op = xsync.UpdateOp
			return
		}
		// Here, the value is already greater than minVal, so instead of
		// updating the map, do nothing.
		op = xsync.CancelOp
		return
	})
	// v: 84, ok: true, oldVal: 84
	fmt.Printf("v: %v, ok: %v, oldVal: %v\n", v, ok, oldVal)

	// Delete an existing value.
	v, ok = counts.Compute(42, func(oldValue int, loaded bool) (newValue int, op xsync.ComputeOp) {
		// loaded is true here.
		op = xsync.DeleteOp
		return
	})
	// v: 84, ok: false
	fmt.Printf("v: %v, ok: %v\n", v, ok)

	// Propagate an error from the compute function to the outer scope.
	var err error
	v, ok = counts.Compute(42, func(oldValue int, loaded bool) (newValue int, op xsync.ComputeOp) {
		if oldValue == 42 {
			err = errors.New("something went wrong")
			return 0, xsync.CancelOp // no need to create a key/value pair
		}
		newValue = 0
		op = xsync.UpdateOp
		return
	})
	fmt.Printf("err: %v\n", err)
}
```

</p>
</details>

<a name="MapStats"></a>
## type [MapStats](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L841-L875>)

MapStats is Map statistics.

Warning: map statistics are intented to be used for diagnostic purposes, not for production code. This means that breaking changes may be introduced into this struct even between minor releases.

```go
type MapStats struct {
    // RootBuckets is the number of root buckets in the hash table.
    // Each bucket holds a few entries.
    RootBuckets int
    // TotalBuckets is the total number of buckets in the hash table,
    // including root and their chained buckets. Each bucket holds
    // a few entries.
    TotalBuckets int
    // EmptyBuckets is the number of buckets that hold no entries.
    EmptyBuckets int
    // Capacity is the Map capacity, i.e. the total number of
    // entries that all buckets can physically hold. This number
    // does not consider the load factor.
    Capacity int
    // Size is the exact number of entries stored in the map.
    Size int
    // Counter is the number of entries stored in the map according
    // to the internal atomic counter. In case of concurrent map
    // modifications this number may be different from Size.
    Counter int
    // CounterLen is the number of internal atomic counter stripes.
    // This number may grow with the map capacity to improve
    // multithreaded scalability.
    CounterLen int
    // MinEntries is the minimum number of entries per a chain of
    // buckets, i.e. a root bucket and its chained buckets.
    MinEntries int
    // MinEntries is the maximum number of entries per a chain of
    // buckets, i.e. a root bucket and its chained buckets.
    MaxEntries int
    // TotalGrowths is the number of times the hash table grew.
    TotalGrowths int64
    // TotalGrowths is the number of times the hash table shrinked.
    TotalShrinks int64
}
```

<a name="MapStats.ToString"></a>
### func \(\*MapStats\) [ToString](<https://github.com/fufuok/cache/blob/master/xsync/map.go#L878>)

```go
func (s *MapStats) ToString() string
```

ToString returns string representation of map stats.

<a name="RBMutex"></a>
## type [RBMutex](<https://github.com/fufuok/cache/blob/master/xsync/rbmutex.go#L42-L48>)

A RBMutex is a reader biased reader/writer mutual exclusion lock. The lock can be held by an many readers or a single writer. The zero value for a RBMutex is an unlocked mutex.

A RBMutex must not be copied after first use.

RBMutex is based on a modified version of BRAVO \(Biased Locking for Reader\-Writer Locks\) algorithm: https://arxiv.org/pdf/1810.01553.pdf

RBMutex is a specialized mutex for scenarios, such as caches, where the vast majority of locks are acquired by readers and write lock acquire attempts are infrequent. In such scenarios, RBMutex performs better than sync.RWMutex on large multicore machines.

RBMutex extends sync.RWMutex internally and uses it as the "reader bias disabled" fallback, so the same semantics apply. The only noticeable difference is in reader tokens returned from the RLock/RUnlock methods.

```go
type RBMutex struct {
    // contains filtered or unexported fields
}
```

<a name="NewRBMutex"></a>
### func [NewRBMutex](<https://github.com/fufuok/cache/blob/master/xsync/rbmutex.go#L57>)

```go
func NewRBMutex() *RBMutex
```

NewRBMutex creates a new RBMutex instance.

<a name="RBMutex.Lock"></a>
### func \(\*RBMutex\) [Lock](<https://github.com/fufuok/cache/blob/master/xsync/rbmutex.go#L166>)

```go
func (mu *RBMutex) Lock()
```

Lock locks m for writing. If the lock is already locked for reading or writing, Lock blocks until the lock is available.

<a name="RBMutex.RLock"></a>
### func \(\*RBMutex\) [RLock](<https://github.com/fufuok/cache/blob/master/xsync/rbmutex.go#L89>)

```go
func (mu *RBMutex) RLock() *RToken
```

RLock locks m for reading and returns a reader token. The token must be used in the later RUnlock call.

Should not be used for recursive read locking; a blocked Lock call excludes new readers from acquiring the lock.

<a name="RBMutex.RUnlock"></a>
### func \(\*RBMutex\) [RUnlock](<https://github.com/fufuok/cache/blob/master/xsync/rbmutex.go#L134>)

```go
func (mu *RBMutex) RUnlock(t *RToken)
```

RUnlock undoes a single RLock call. A reader token obtained from the RLock call must be provided. RUnlock does not affect other simultaneous readers. A panic is raised if m is not locked for reading on entry to RUnlock.

<a name="RBMutex.TryLock"></a>
### func \(\*RBMutex\) [TryLock](<https://github.com/fufuok/cache/blob/master/xsync/rbmutex.go#L146>)

```go
func (mu *RBMutex) TryLock() bool
```

TryLock tries to lock m for writing without blocking.

<a name="RBMutex.TryRLock"></a>
### func \(\*RBMutex\) [TryRLock](<https://github.com/fufuok/cache/blob/master/xsync/rbmutex.go#L70>)

```go
func (mu *RBMutex) TryRLock() (bool, *RToken)
```

TryRLock tries to lock m for reading without blocking. When TryRLock succeeds, it returns true and a reader token. In case of a failure, a false is returned.

<a name="RBMutex.Unlock"></a>
### func \(\*RBMutex\) [Unlock](<https://github.com/fufuok/cache/blob/master/xsync/rbmutex.go#L186>)

```go
func (mu *RBMutex) Unlock()
```

Unlock unlocks m for writing. A panic is raised if m is not locked for writing on entry to Unlock.

As with RWMutex, a locked RBMutex is not associated with a particular goroutine. One goroutine may RLock \(Lock\) a RBMutex and then arrange for another goroutine to RUnlock \(Unlock\) it.

<a name="RToken"></a>
## type [RToken](<https://github.com/fufuok/cache/blob/master/xsync/rbmutex.go#L17-L21>)

RToken is a reader lock token.

```go
type RToken struct {
    // contains filtered or unexported fields
}
```

<a name="SPSCQueue"></a>
## type [SPSCQueue](<https://github.com/fufuok/cache/blob/master/xsync/spscqueue.go#L20-L32>)

A SPSCQueue is a bounded single\-producer single\-consumer concurrent queue. This means that not more than a single goroutine must be publishing items to the queue while not more than a single goroutine must be consuming those items.

SPSCQueue instances must be created with NewSPSCQueue function. A SPSCQueue must not be copied after first use.

Based on the data structure from the following article: https://rigtorp.se/ringbuffer/

```go
type SPSCQueue[I any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewSPSCQueue"></a>
### func [NewSPSCQueue](<https://github.com/fufuok/cache/blob/master/xsync/spscqueue.go#L41>)

```go
func NewSPSCQueue[I any](capacity int) *SPSCQueue[I]
```

NewSPSCQueue creates a new SPSCQueue instance with the given capacity.

<a name="NewSPSCQueueOf"></a>
### func [NewSPSCQueueOf](<https://github.com/fufuok/cache/blob/master/xsync/spscqueue.go#L35>)

```go
func NewSPSCQueueOf[I any](capacity int) *SPSCQueue[I]
```

Deprecated: use [NewSPSCQueue](<#NewSPSCQueue>).

<a name="SPSCQueue[I].TryDequeue"></a>
### func \(\*SPSCQueue\[I\]\) [TryDequeue](<https://github.com/fufuok/cache/blob/master/xsync/spscqueue.go#L77>)

```go
func (q *SPSCQueue[I]) TryDequeue() (item I, ok bool)
```

TryDequeue retrieves and removes the item from the head of the queue. Does not block and returns immediately. The ok result indicates that the queue isn't empty and an item was retrieved.

<a name="SPSCQueue[I].TryEnqueue"></a>
### func \(\*SPSCQueue\[I\]\) [TryEnqueue](<https://github.com/fufuok/cache/blob/master/xsync/spscqueue.go#L54>)

```go
func (q *SPSCQueue[I]) TryEnqueue(item I) bool
```

TryEnqueue inserts the given item into the queue. Does not block and returns immediately. The result indicates that the queue isn't full and the item was inserted.

<a name="SPSCQueueOf"></a>
## type [SPSCQueueOf](<https://github.com/fufuok/cache/blob/master/xsync/spscqueue.go#L8>)

Deprecated: use [SPSCQueue](<#SPSCQueue>).

```go
type SPSCQueueOf[I any] = SPSCQueue[I]
```

<a name="UMPSCQueue"></a>
## type [UMPSCQueue](<https://github.com/fufuok/cache/blob/master/xsync/umpscqueue.go#L27-L39>)

A UMPSCQueue an unbounded multi\-producer single\-consumer concurrent queue. It is meant to serve as a replacement for a channel. However, crucially, it has infinite capacity. This is a very bad idea in many cases as it means that it never exhibits backpressure. In other words, if nothing is consuming elements from the queue, it will eventually consume all available memory and crash the process. However, there are also cases where this is desired behavior as it means the queue will dynamically allocate more memory to store temporary bursts, allowing producers to never block while the consumer catches up.

Note however that because no locks are acquired, it is unsafe for multiple goroutines to consume from the queue. Consumers must explicitly synchronize between themselves.

```go
type UMPSCQueue[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewUMPSCQueue"></a>
### func [NewUMPSCQueue](<https://github.com/fufuok/cache/blob/master/xsync/umpscqueue.go#L10>)

```go
func NewUMPSCQueue[T any]() *UMPSCQueue[T]
```

NewUMPSCQueue creates a new UMPSCQueue instance.

<a name="UMPSCQueue[T].Dequeue"></a>
### func \(\*UMPSCQueue\[T\]\) [Dequeue](<https://github.com/fufuok/cache/blob/master/xsync/umpscqueue.go#L114>)

```go
func (q *UMPSCQueue[T]) Dequeue() T
```

Dequeue returns the next value in the queue, blocking if it is empty. It is not safe to invoke Dequeue from multiple goroutines.

<a name="UMPSCQueue[T].Enqueue"></a>
### func \(\*UMPSCQueue\[T\]\) [Enqueue](<https://github.com/fufuok/cache/blob/master/xsync/umpscqueue.go#L131>)

```go
func (q *UMPSCQueue[T]) Enqueue(value T)
```

Enqueue writes the given value to the queue. It never blocks and is safe to be called by multiple goroutines concurrently.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
