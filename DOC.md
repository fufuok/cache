<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# cache

```go
import "github.com/fufuok/cache"
```

## Index

- [Constants](<#constants>)
- [type Cache](<#Cache>)
  - [func New\(opts ...Option\) Cache](<#New>)
  - [func NewDefault\(defaultExpiration, cleanupInterval time.Duration, evictedCallback ...EvictedCallback\) Cache](<#NewDefault>)
- [type CacheOf](<#CacheOf>)
  - [func NewOf\[K comparable, V any\]\(opts ...OptionOf\[K, V\]\) CacheOf\[K, V\]](<#NewOf>)
  - [func NewOfDefault\[K comparable, V any\]\(defaultExpiration, cleanupInterval time.Duration, evictedCallback ...EvictedCallbackOf\[K, V\]\) CacheOf\[K, V\]](<#NewOfDefault>)
- [type Config](<#Config>)
  - [func DefaultConfig\(\) Config](<#DefaultConfig>)
- [type ConfigOf](<#ConfigOf>)
  - [func DefaultConfigOf\[K comparable, V any\]\(\) ConfigOf\[K, V\]](<#DefaultConfigOf>)
- [type EvictedCallback](<#EvictedCallback>)
- [type EvictedCallbackOf](<#EvictedCallbackOf>)
- [type Map](<#Map>)
  - [func NewMap\(\) Map](<#NewMap>)
  - [func NewMapPresized\(sizeHint int\) Map](<#NewMapPresized>)
- [type MapOf](<#MapOf>)
  - [func NewMapOf\[K comparable, V any\]\(\) MapOf\[K, V\]](<#NewMapOf>)
  - [func NewMapOfPresized\[K comparable, V any\]\(sizeHint int\) MapOf\[K, V\]](<#NewMapOfPresized>)
- [type Option](<#Option>)
  - [func WithCleanupInterval\(interval time.Duration\) Option](<#WithCleanupInterval>)
  - [func WithDefaultExpiration\(duration time.Duration\) Option](<#WithDefaultExpiration>)
  - [func WithEvictedCallback\(ec EvictedCallback\) Option](<#WithEvictedCallback>)
  - [func WithMinCapacity\(sizeHint int\) Option](<#WithMinCapacity>)
- [type OptionOf](<#OptionOf>)
  - [func WithCleanupIntervalOf\[K comparable, V any\]\(interval time.Duration\) OptionOf\[K, V\]](<#WithCleanupIntervalOf>)
  - [func WithDefaultExpirationOf\[K comparable, V any\]\(duration time.Duration\) OptionOf\[K, V\]](<#WithDefaultExpirationOf>)
  - [func WithEvictedCallbackOf\[K comparable, V any\]\(ec EvictedCallbackOf\[K, V\]\) OptionOf\[K, V\]](<#WithEvictedCallbackOf>)
  - [func WithMinCapacityOf\[K comparable, V any\]\(sizeHint int\) OptionOf\[K, V\]](<#WithMinCapacityOf>)


## Constants

<a name="NoExpiration"></a>

```go
const (
    // NoExpiration mark cached item never expire.
    NoExpiration = -2 * time.Second

    // DefaultExpiration use the default expiration time set when the cache was created.
    // Equivalent to passing in the same e duration as was given to NewCache() or NewCacheDefault().
    DefaultExpiration = -1 * time.Second

    // DefaultCleanupInterval the default time interval for automatically cleaning up expired key-value pairs
    DefaultCleanupInterval = 10 * time.Second

    // DefaultMinCapacity specify the initial cache capacity (minimum capacity)
    DefaultMinCapacity = 32 * 3
)
```

<a name="Cache"></a>
## type [Cache](<https://github.com/fufuok/cache/blob/master/cache.go#L7-L114>)



```go
type Cache interface {
    // Set add item to the cache, replacing any existing items.
    // (DefaultExpiration), the item uses a cached default expiration time.
    // (NoExpiration), the item never expires.
    // All values less than or equal to 0 are the same except DefaultExpiration,
    // which means never expires.
    Set(k string, v interface{}, d time.Duration)

    // SetDefault add item to the cache with the default expiration time,
    // replacing any existing items.
    SetDefault(k string, v interface{})

    // SetForever add item to cache and set to never expire, replacing any existing items.
    SetForever(k string, v interface{})

    // Get an item from the cache.
    // Returns the item or nil,
    // and a boolean indicating whether the key was found.
    Get(k string) (value interface{}, ok bool)

    // GetWithExpiration get an item from the cache.
    // Returns the item or nil,
    // along with the expiration time, and a boolean indicating whether the key was found.
    GetWithExpiration(k string) (value interface{}, expiration time.Time, ok bool)

    // GetWithTTL get an item from the cache.
    // Returns the item or nil,
    // with the remaining lifetime and a boolean indicating whether the key was found.
    GetWithTTL(k string) (value interface{}, ttl time.Duration, ok bool)

    // GetOrSet returns the existing value for the key if present.
    // Otherwise, it stores and returns the given value.
    // The loaded result is true if the value was loaded, false if stored.
    GetOrSet(k string, v interface{}, d time.Duration) (value interface{}, loaded bool)

    // GetAndSet returns the existing value for the key if present,
    // while setting the new value for the key.
    // Otherwise, it stores and returns the given value.
    // The loaded result is true if the value was loaded, false otherwise.
    GetAndSet(k string, v interface{}, d time.Duration) (value interface{}, loaded bool)

    // GetAndRefresh Get an item from the cache, and refresh the item's expiration time.
    // Returns the item or nil,
    // and a boolean indicating whether the key was found.
    GetAndRefresh(k string, d time.Duration) (value interface{}, loaded bool)

    // GetOrCompute returns the existing value for the key if present.
    // Otherwise, it computes the value using the provided function and
    // returns the computed value. The loaded result is true if the value
    // was loaded, false if stored.
    GetOrCompute(k string, valueFn func() interface{}, d time.Duration) (interface{}, bool)

    // Compute either sets the computed new value for the key or deletes
    // the value for the key. When the delete result of the valueFn function
    // is set to true, the value will be deleted, if it exists. When delete
    // is set to false, the value is updated to the newValue.
    // The ok result indicates whether value was computed and stored, thus, is
    // present in the map. The actual result contains the new value in cases where
    // the value was computed and stored. See the example for a few use cases.
    Compute(
        k string,
        valueFn func(oldValue interface{}, loaded bool) (newValue interface{}, delete bool),
        d time.Duration,
    ) (interface{}, bool)

    // GetAndDelete Get an item from the cache, and delete the key.
    // Returns the item or nil,
    // and a boolean indicating whether the key was found.
    GetAndDelete(k string) (value interface{}, loaded bool)

    // Delete an item from the cache.
    // Does nothing if the key is not in the cache.
    Delete(k string)

    // DeleteExpired delete all expired items from the cache.
    DeleteExpired()

    // Range calls f sequentially for each key and value present in the map.
    // If f returns false, range stops the iteration.
    Range(f func(k string, v interface{}) bool)

    // Items return the items in the cache.
    // This is a snapshot, which may include items that are about to expire.
    Items() map[string]interface{}

    // Clear deletes all keys and values currently stored in the map.
    Clear()

    // Count returns the number of items in the cache.
    // This may include items that have expired but have not been cleaned up.
    Count() int

    // DefaultExpiration returns the default expiration time for the cache.
    DefaultExpiration() time.Duration

    // SetDefaultExpiration sets the default expiration time for the cache.
    // Atomic safety.
    SetDefaultExpiration(defaultExpiration time.Duration)

    // EvictedCallback returns the callback function to execute
    // when a key-value pair expires and is evicted.
    EvictedCallback() EvictedCallback

    // SetEvictedCallback Set the callback function to be executed
    // when the key-value pair expires and is evicted.
    // Atomic safety.
    SetEvictedCallback(evictedCallback EvictedCallback)
}
```

<a name="New"></a>
### func [New](<https://github.com/fufuok/cache/blob/master/cache.go#L116>)

```go
func New(opts ...Option) Cache
```



<a name="NewDefault"></a>
### func [NewDefault](<https://github.com/fufuok/cache/blob/master/cache.go#L124-L128>)

```go
func NewDefault(defaultExpiration, cleanupInterval time.Duration, evictedCallback ...EvictedCallback) Cache
```



<a name="CacheOf"></a>
## type [CacheOf](<https://github.com/fufuok/cache/blob/master/cacheof.go#L10-L117>)



```go
type CacheOf[K comparable, V any] interface {
    // Set add item to the cache, replacing any existing items.
    // (DefaultExpiration), the item uses a cached default expiration time.
    // (NoExpiration), the item never expires.
    // All values less than or equal to 0 are the same except DefaultExpiration,
    // which means never expires.
    Set(k K, v V, d time.Duration)

    // SetDefault add item to the cache with the default expiration time,
    // replacing any existing items.
    SetDefault(k K, v V)

    // SetForever add item to cache and set to never expire, replacing any existing items.
    SetForever(k K, v V)

    // Get an item from the cache.
    // Returns the item or nil,
    // and a boolean indicating whether the key was found.
    Get(k K) (value V, ok bool)

    // GetWithExpiration get an item from the cache.
    // Returns the item or nil,
    // along with the expiration time, and a boolean indicating whether the key was found.
    GetWithExpiration(k K) (value V, expiration time.Time, ok bool)

    // GetWithTTL get an item from the cache.
    // Returns the item or nil,
    // with the remaining lifetime and a boolean indicating whether the key was found.
    GetWithTTL(k K) (value V, ttl time.Duration, ok bool)

    // GetOrSet returns the existing value for the key if present.
    // Otherwise, it stores and returns the given value.
    // The loaded result is true if the value was loaded, false if stored.
    GetOrSet(k K, v V, d time.Duration) (value V, loaded bool)

    // GetAndSet returns the existing value for the key if present,
    // while setting the new value for the key.
    // Otherwise, it stores and returns the given value.
    // The loaded result is true if the value was loaded, false otherwise.
    GetAndSet(k K, v V, d time.Duration) (value V, loaded bool)

    // GetAndRefresh Get an item from the cache, and refresh the item's expiration time.
    // Returns the item or nil,
    // and a boolean indicating whether the key was found.
    GetAndRefresh(k K, d time.Duration) (value V, loaded bool)

    // GetOrCompute returns the existing value for the key if present.
    // Otherwise, it computes the value using the provided function and
    // returns the computed value. The loaded result is true if the value
    // was loaded, false if stored.
    GetOrCompute(k K, valueFn func() V, d time.Duration) (V, bool)

    // Compute either sets the computed new value for the key or deletes
    // the value for the key. When the delete result of the valueFn function
    // is set to true, the value will be deleted, if it exists. When delete
    // is set to false, the value is updated to the newValue.
    // The ok result indicates whether value was computed and stored, thus, is
    // present in the map. The actual result contains the new value in cases where
    // the value was computed and stored. See the example for a few use cases.
    Compute(
        k K,
        valueFn func(oldValue V, loaded bool) (newValue V, delete bool),
        d time.Duration,
    ) (V, bool)

    // GetAndDelete Get an item from the cache, and delete the key.
    // Returns the item or nil,
    // and a boolean indicating whether the key was found.
    GetAndDelete(k K) (value V, loaded bool)

    // Delete an item from the cache.
    // Does nothing if the key is not in the cache.
    Delete(k K)

    // DeleteExpired delete all expired items from the cache.
    DeleteExpired()

    // Range calls f sequentially for each key and value present in the map.
    // If f returns false, range stops the iteration.
    Range(f func(k K, v V) bool)

    // Items return the items in the cache.
    // This is a snapshot, which may include items that are about to expire.
    Items() map[K]V

    // Clear deletes all keys and values currently stored in the map.
    Clear()

    // Count returns the number of items in the cache.
    // This may include items that have expired but have not been cleaned up.
    Count() int

    // DefaultExpiration returns the default expiration time for the cache.
    DefaultExpiration() time.Duration

    // SetDefaultExpiration sets the default expiration time for the cache.
    // Atomic safety.
    SetDefaultExpiration(defaultExpiration time.Duration)

    // EvictedCallback returns the callback function to execute
    // when a key-value pair expires and is evicted.
    EvictedCallback() EvictedCallbackOf[K, V]

    // SetEvictedCallback Set the callback function to be executed
    // when the key-value pair expires and is evicted.
    // Atomic safety.
    SetEvictedCallback(evictedCallback EvictedCallbackOf[K, V])
}
```

<a name="NewOf"></a>
### func [NewOf](<https://github.com/fufuok/cache/blob/master/cacheof.go#L119>)

```go
func NewOf[K comparable, V any](opts ...OptionOf[K, V]) CacheOf[K, V]
```



<a name="NewOfDefault"></a>
### func [NewOfDefault](<https://github.com/fufuok/cache/blob/master/cacheof.go#L127-L131>)

```go
func NewOfDefault[K comparable, V any](defaultExpiration, cleanupInterval time.Duration, evictedCallback ...EvictedCallbackOf[K, V]) CacheOf[K, V]
```



<a name="Config"></a>
## type [Config](<https://github.com/fufuok/cache/blob/master/config.go#L26-L38>)



```go
type Config struct {
    // DefaultExpiration default expiration time for key-value pairs.
    DefaultExpiration time.Duration

    // CleanupInterval the interval at which expired key-value pairs are automatically cleaned up.
    CleanupInterval time.Duration

    // EvictedCallback executed when the key-value pair expires.
    EvictedCallback EvictedCallback

    // MinCapacity specify the initial cache capacity (minimum capacity)
    MinCapacity int
}
```

<a name="DefaultConfig"></a>
### func [DefaultConfig](<https://github.com/fufuok/cache/blob/master/config.go#L40>)

```go
func DefaultConfig() Config
```



<a name="ConfigOf"></a>
## type [ConfigOf](<https://github.com/fufuok/cache/blob/master/configof.go#L14-L26>)



```go
type ConfigOf[K comparable, V any] struct {
    // DefaultExpiration default expiration time for key-value pairs.
    DefaultExpiration time.Duration

    // CleanupInterval the interval at which expired key-value pairs are automatically cleaned up.
    CleanupInterval time.Duration

    // EvictedCallback executed when the key-value pair expires.
    EvictedCallback EvictedCallbackOf[K, V]

    // MinCapacity specify the initial cache capacity (minimum capacity)
    MinCapacity int
}
```

<a name="DefaultConfigOf"></a>
### func [DefaultConfigOf](<https://github.com/fufuok/cache/blob/master/configof.go#L28>)

```go
func DefaultConfigOf[K comparable, V any]() ConfigOf[K, V]
```



<a name="EvictedCallback"></a>
## type [EvictedCallback](<https://github.com/fufuok/cache/blob/master/config.go#L24>)

EvictedCallback callback function to execute when the key\-value pair expires and is evicted. Warning: cannot block, it is recommended to use goroutine.

```go
type EvictedCallback func(k string, v interface{})
```

<a name="EvictedCallbackOf"></a>
## type [EvictedCallbackOf](<https://github.com/fufuok/cache/blob/master/configof.go#L12>)

EvictedCallbackOf callback function to execute when the key\-value pair expires and is evicted. Warning: cannot block, it is recommended to use goroutine.

```go
type EvictedCallbackOf[K comparable, V any] func(k K, v V)
```

<a name="Map"></a>
## type [Map](<https://github.com/fufuok/cache/blob/master/map.go#L7-L73>)



```go
type Map interface {
    // Load returns the value stored in the map for a key, or nil if no
    // value is present.
    // The ok result indicates whether value was found in the map.
    Load(key string) (value interface{}, ok bool)

    // Store sets the value for a key.
    Store(key string, value interface{})

    // LoadOrStore returns the existing value for the key if present.
    // Otherwise, it stores and returns the given value.
    // The loaded result is true if the value was loaded, false if stored.
    LoadOrStore(key string, value interface{}) (actual interface{}, loaded bool)

    // LoadAndStore returns the existing value for the key if present,
    // while setting the new value for the key.
    // It stores the new value and returns the existing one, if present.
    // The loaded result is true if the existing value was loaded,
    // false otherwise.
    LoadAndStore(key string, value interface{}) (actual interface{}, loaded bool)

    // LoadOrCompute returns the existing value for the key if present.
    // Otherwise, it computes the value using the provided function and
    // returns the computed value. The loaded result is true if the value
    // was loaded, false if stored.
    LoadOrCompute(key string, valueFn func() interface{}) (actual interface{}, loaded bool)

    // Compute either sets the computed new value for the key or deletes
    // the value for the key. When the delete result of the valueFn function
    // is set to true, the value will be deleted, if it exists. When delete
    // is set to false, the value is updated to the newValue.
    // The ok result indicates whether value was computed and stored, thus, is
    // present in the map. The actual result contains the new value in cases where
    // the value was computed and stored. See the example for a few use cases.
    Compute(
        key string,
        valueFn func(oldValue interface{}, loaded bool) (newValue interface{}, delete bool),
    ) (actual interface{}, ok bool)

    // LoadAndDelete deletes the value for a key, returning the previous
    // value if any. The loaded result reports whether the key was
    // present.
    LoadAndDelete(key string) (value interface{}, loaded bool)

    // Delete deletes the value for a key.
    Delete(key string)

    // Range calls f sequentially for each key and value present in the
    // map. If f returns false, range stops the iteration.
    //
    // Range does not necessarily correspond to any consistent snapshot
    // of the Map's contents: no key will be visited more than once, but
    // if the value for any key is stored or deleted concurrently, Range
    // may reflect any mapping for that key from any point during the
    // Range call.
    //
    // It is safe to modify the map while iterating it. However, the
    // concurrent modification rule apply, i.e. the changes may be not
    // reflected in the subsequently iterated entries.
    Range(f func(key string, value interface{}) bool)

    // Clear deletes all keys and values currently stored in the map.
    Clear()

    // Size returns current size of the map.
    Size() int
}
```

<a name="NewMap"></a>
### func [NewMap](<https://github.com/fufuok/cache/blob/master/map.go#L76>)

```go
func NewMap() Map
```

NewMap the keys never expire, similar to the use of sync.Map.

<a name="NewMapPresized"></a>
### func [NewMapPresized](<https://github.com/fufuok/cache/blob/master/map.go#L82>)

```go
func NewMapPresized(sizeHint int) Map
```

NewMapPresized creates a new Map instance with capacity enough to hold sizeHint entries. If sizeHint is zero or negative, the value is ignored.

<a name="MapOf"></a>
## type [MapOf](<https://github.com/fufuok/cache/blob/master/mapof.go#L10-L76>)



```go
type MapOf[K comparable, V any] interface {
    // Load returns the value stored in the map for a key, or nil if no
    // value is present.
    // The ok result indicates whether value was found in the map.
    Load(key K) (value V, ok bool)

    // Store sets the value for a key.
    Store(key K, value V)

    // LoadOrStore returns the existing value for the key if present.
    // Otherwise, it stores and returns the given value.
    // The loaded result is true if the value was loaded, false if stored.
    LoadOrStore(key K, value V) (actual V, loaded bool)

    // LoadAndStore returns the existing value for the key if present,
    // while setting the new value for the key.
    // It stores the new value and returns the existing one, if present.
    // The loaded result is true if the existing value was loaded,
    // false otherwise.
    LoadAndStore(key K, value V) (actual V, loaded bool)

    // LoadOrCompute returns the existing value for the key if present.
    // Otherwise, it computes the value using the provided function and
    // returns the computed value. The loaded result is true if the value
    // was loaded, false if stored.
    LoadOrCompute(key K, valueFn func() V) (actual V, loaded bool)

    // Compute either sets the computed new value for the key or deletes
    // the value for the key. When the delete result of the valueFn function
    // is set to true, the value will be deleted, if it exists. When delete
    // is set to false, the value is updated to the newValue.
    // The ok result indicates whether value was computed and stored, thus, is
    // present in the map. The actual result contains the new value in cases where
    // the value was computed and stored. See the example for a few use cases.
    Compute(
        key K,
        valueFn func(oldValue V, loaded bool) (newValue V, delete bool),
    ) (actual V, ok bool)

    // LoadAndDelete deletes the value for a key, returning the previous
    // value if any. The loaded result reports whether the key was
    // present.
    LoadAndDelete(key K) (value V, loaded bool)

    // Delete deletes the value for a key.
    Delete(key K)

    // Range calls f sequentially for each key and value present in the
    // map. If f returns false, range stops the iteration.
    //
    // Range does not necessarily correspond to any consistent snapshot
    // of the Map's contents: no key will be visited more than once, but
    // if the value for any key is stored or deleted concurrently, Range
    // may reflect any mapping for that key from any point during the
    // Range call.
    //
    // It is safe to modify the map while iterating it. However, the
    // concurrent modification rule apply, i.e. the changes may be not
    // reflected in the subsequently iterated entries.
    Range(f func(key K, value V) bool)

    // Clear deletes all keys and values currently stored in the map.
    Clear()

    // Size returns current size of the map.
    Size() int
}
```

<a name="NewMapOf"></a>
### func [NewMapOf](<https://github.com/fufuok/cache/blob/master/mapof.go#L80>)

```go
func NewMapOf[K comparable, V any]() MapOf[K, V]
```

NewMapOf creates a new HashMapOf instance with string keys. The keys never expire, similar to the use of sync.Map.

<a name="NewMapOfPresized"></a>
### func [NewMapOfPresized](<https://github.com/fufuok/cache/blob/master/mapof.go#L87>)

```go
func NewMapOfPresized[K comparable, V any](sizeHint int) MapOf[K, V]
```

NewMapOfPresized creates a new MapOf instance with string keys and capacity enough to hold sizeHint entries. If sizeHint is zero or negative, the value is ignored.

<a name="Option"></a>
## type [Option](<https://github.com/fufuok/cache/blob/master/options.go#L7>)



```go
type Option func(config *Config)
```

<a name="WithCleanupInterval"></a>
### func [WithCleanupInterval](<https://github.com/fufuok/cache/blob/master/options.go#L15>)

```go
func WithCleanupInterval(interval time.Duration) Option
```



<a name="WithDefaultExpiration"></a>
### func [WithDefaultExpiration](<https://github.com/fufuok/cache/blob/master/options.go#L9>)

```go
func WithDefaultExpiration(duration time.Duration) Option
```



<a name="WithEvictedCallback"></a>
### func [WithEvictedCallback](<https://github.com/fufuok/cache/blob/master/options.go#L21>)

```go
func WithEvictedCallback(ec EvictedCallback) Option
```



<a name="WithMinCapacity"></a>
### func [WithMinCapacity](<https://github.com/fufuok/cache/blob/master/options.go#L27>)

```go
func WithMinCapacity(sizeHint int) Option
```



<a name="OptionOf"></a>
## type [OptionOf](<https://github.com/fufuok/cache/blob/master/optionsof.go#L10>)



```go
type OptionOf[K comparable, V any] func(config *ConfigOf[K, V])
```

<a name="WithCleanupIntervalOf"></a>
### func [WithCleanupIntervalOf](<https://github.com/fufuok/cache/blob/master/optionsof.go#L18>)

```go
func WithCleanupIntervalOf[K comparable, V any](interval time.Duration) OptionOf[K, V]
```



<a name="WithDefaultExpirationOf"></a>
### func [WithDefaultExpirationOf](<https://github.com/fufuok/cache/blob/master/optionsof.go#L12>)

```go
func WithDefaultExpirationOf[K comparable, V any](duration time.Duration) OptionOf[K, V]
```



<a name="WithEvictedCallbackOf"></a>
### func [WithEvictedCallbackOf](<https://github.com/fufuok/cache/blob/master/optionsof.go#L24>)

```go
func WithEvictedCallbackOf[K comparable, V any](ec EvictedCallbackOf[K, V]) OptionOf[K, V]
```



<a name="WithMinCapacityOf"></a>
### func [WithMinCapacityOf](<https://github.com/fufuok/cache/blob/master/optionsof.go#L30>)

```go
func WithMinCapacityOf[K comparable, V any](sizeHint int) OptionOf[K, V]
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
