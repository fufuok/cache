<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# cache

```go
import "github.com/fufuok/cache"
```

## Index

- [Constants](<#constants>)
- [type Cache](<#type-cache>)
  - [func New(opts ...Option) Cache](<#func-new>)
  - [func NewDefault(defaultExpiration, cleanupInterval time.Duration, evictedCallback ...EvictedCallback) Cache](<#func-newdefault>)
- [type CacheOf](<#type-cacheof>)
  - [func NewOf[V any](opts ...OptionOf[V]) CacheOf[V]](<#func-newof>)
  - [func NewOfDefault[V any](defaultExpiration, cleanupInterval time.Duration, evictedCallback ...EvictedCallbackOf[V]) CacheOf[V]](<#func-newofdefault>)
- [type Config](<#type-config>)
  - [func DefaultConfig() Config](<#func-defaultconfig>)
- [type ConfigOf](<#type-configof>)
  - [func DefaultConfigOf[V any]() ConfigOf[V]](<#func-defaultconfigof>)
- [type EvictedCallback](<#type-evictedcallback>)
- [type EvictedCallbackOf](<#type-evictedcallbackof>)
- [type Map](<#type-map>)
  - [func NewMap() Map](<#func-newmap>)
- [type MapOf](<#type-mapof>)
  - [func NewMapOf[V any]() MapOf[V]](<#func-newmapof>)
- [type Option](<#type-option>)
  - [func WithCleanupInterval(interval time.Duration) Option](<#func-withcleanupinterval>)
  - [func WithDefaultExpiration(duration time.Duration) Option](<#func-withdefaultexpiration>)
  - [func WithEvictedCallback(ec EvictedCallback) Option](<#func-withevictedcallback>)
- [type OptionOf](<#type-optionof>)
  - [func WithCleanupIntervalOf[V any](interval time.Duration) OptionOf[V]](<#func-withcleanupintervalof>)
  - [func WithDefaultExpirationOf[V any](duration time.Duration) OptionOf[V]](<#func-withdefaultexpirationof>)
  - [func WithEvictedCallbackOf[V any](ec EvictedCallbackOf[V]) OptionOf[V]](<#func-withevictedcallbackof>)


## Constants

```go
const (
    // NoExpiration mark cached item never expire.
    NoExpiration = -2 * time.Second

    // DefaultExpiration use the default expiration time set when the cache was created.
    // Equivalent to passing in the same e duration as was given to NewCache() or NewCacheDefault().
    DefaultExpiration = -1 * time.Second

    // DefaultCleanupInterval the default time interval for automatically cleaning up expired key-value pairs
    DefaultCleanupInterval = 10 * time.Second
)
```

## type Cache

```go
type Cache interface {
    // Set add item to the cache, replacing any existing items.
    // (DefaultExpiration), the item uses a cached default expiration time.
    // (NoExpiration), the item never expires.
    // All values less than or equal to 0 are the same except DefaultExpiration,
    // which means never expires.
    Set(k string, v interface{}, d time.Duration)

    // SetDefault add item to the cache with the default expiration time,
    // replacing any existing items.
    SetDefault(k string, v interface{})

    // SetForever add item to cache and set to never expire, replacing any existing items.
    SetForever(k string, v interface{})

    // Get an item from the cache.
    // Returns the item or nil,
    // and a boolean indicating whether the key was found.
    Get(k string) (interface{}, bool)

    // GetWithExpiration get an item from the cache.
    // Returns the item or nil,
    // along with the expiration time, and a boolean indicating whether the key was found.
    GetWithExpiration(k string) (interface{}, time.Time, bool)

    // GetWithTTL get an item from the cache.
    // Returns the item or nil,
    // with the remaining lifetime and a boolean indicating whether the key was found.
    GetWithTTL(k string) (interface{}, time.Duration, bool)

    // GetOrSet returns the existing value for the key if present.
    // Otherwise, it stores and returns the given value.
    // The loaded result is true if the value was loaded, false if stored.
    GetOrSet(k string, v interface{}, d time.Duration) (interface{}, bool)

    // GetAndSet returns the existing value for the key if present,
    // while setting the new value for the key.
    // Otherwise, it stores and returns the given value.
    // The loaded result is true if the value was loaded, false otherwise.
    GetAndSet(k string, v interface{}, d time.Duration) (interface{}, bool)

    // GetAndRefresh Get an item from the cache, and refresh the item's expiration time.
    // Returns the item or nil,
    // and a boolean indicating whether the key was found.
    // Allows getting keys that have expired but not been evicted.
    // Not atomic synchronization.
    GetAndRefresh(k string, d time.Duration) (interface{}, bool)

    // GetAndDelete Get an item from the cache, and delete the key.
    // Returns the item or nil,
    // and a boolean indicating whether the key was found.
    GetAndDelete(k string) (interface{}, bool)

    // Delete an item from the cache.
    // Does nothing if the key is not in the cache.
    Delete(k string)

    // DeleteExpired delete all expired items from the cache.
    DeleteExpired()

    // Range calls f sequentially for each key and value present in the map.
    // If f returns false, range stops the iteration.
    Range(f func(k string, v interface{}) bool)

    // Items return the items in the cache.
    // This is a snapshot, which may include items that are about to expire.
    Items() map[string]interface{}

    // Count returns the number of items in the cache.
    // This may include items that have expired but have not been cleaned up.
    Count() int

    // DefaultExpiration returns the default expiration time for the cache.
    DefaultExpiration() time.Duration

    // SetDefaultExpiration sets the default expiration time for the cache.
    // Atomic safety.
    SetDefaultExpiration(defaultExpiration time.Duration)

    // EvictedCallback returns the callback function to execute
    // when a key-value pair expires and is evicted.
    EvictedCallback() EvictedCallback

    // SetEvictedCallback Set the callback function to be executed
    // when the key-value pair expires and is evicted.
    // Atomic safety.
    SetEvictedCallback(evictedCallback EvictedCallback)
}
```

### func New

```go
func New(opts ...Option) Cache
```

### func NewDefault

```go
func NewDefault(defaultExpiration, cleanupInterval time.Duration, evictedCallback ...EvictedCallback) Cache
```

## type CacheOf

```go
type CacheOf[V any] interface {
    // Set add item to the cache, replacing any existing items.
    // (DefaultExpiration), the item uses a cached default expiration time.
    // (NoExpiration), the item never expires.
    // All values less than or equal to 0 are the same except DefaultExpiration,
    // which means never expires.
    Set(k string, v V, d time.Duration)

    // SetDefault add item to the cache with the default expiration time,
    // replacing any existing items.
    SetDefault(k string, v V)

    // SetForever add item to cache and set to never expire, replacing any existing items.
    SetForever(k string, v V)

    // Get an item from the cache.
    // Returns the item or nil,
    // and a boolean indicating whether the key was found.
    Get(k string) (V, bool)

    // GetWithExpiration get an item from the cache.
    // Returns the item or nil,
    // along with the expiration time, and a boolean indicating whether the key was found.
    GetWithExpiration(k string) (V, time.Time, bool)

    // GetWithTTL get an item from the cache.
    // Returns the item or nil,
    // with the remaining lifetime and a boolean indicating whether the key was found.
    GetWithTTL(k string) (V, time.Duration, bool)

    // GetOrSet returns the existing value for the key if present.
    // Otherwise, it stores and returns the given value.
    // The loaded result is true if the value was loaded, false if stored.
    GetOrSet(k string, v V, d time.Duration) (V, bool)

    // GetAndSet returns the existing value for the key if present,
    // while setting the new value for the key.
    // Otherwise, it stores and returns the given value.
    // The loaded result is true if the value was loaded, false otherwise.
    GetAndSet(k string, v V, d time.Duration) (V, bool)

    // GetAndRefresh Get an item from the cache, and refresh the item's expiration time.
    // Returns the item or nil,
    // and a boolean indicating whether the key was found.
    // Allows getting keys that have expired but not been evicted.
    // Not atomic synchronization.
    GetAndRefresh(k string, d time.Duration) (V, bool)

    // GetAndDelete Get an item from the cache, and delete the key.
    // Returns the item or nil,
    // and a boolean indicating whether the key was found.
    GetAndDelete(k string) (V, bool)

    // Delete an item from the cache.
    // Does nothing if the key is not in the cache.
    Delete(k string)

    // DeleteExpired delete all expired items from the cache.
    DeleteExpired()

    // Range calls f sequentially for each key and value present in the map.
    // If f returns false, range stops the iteration.
    Range(f func(k string, v V) bool)

    // Items return the items in the cache.
    // This is a snapshot, which may include items that are about to expire.
    Items() map[string]V

    // Count returns the number of items in the cache.
    // This may include items that have expired but have not been cleaned up.
    Count() int

    // DefaultExpiration returns the default expiration time for the cache.
    DefaultExpiration() time.Duration

    // SetDefaultExpiration sets the default expiration time for the cache.
    // Atomic safety.
    SetDefaultExpiration(defaultExpiration time.Duration)

    // EvictedCallback returns the callback function to execute
    // when a key-value pair expires and is evicted.
    EvictedCallback() EvictedCallbackOf[V]

    // SetEvictedCallback Set the callback function to be executed
    // when the key-value pair expires and is evicted.
    // Atomic safety.
    SetEvictedCallback(evictedCallback EvictedCallbackOf[V])
}
```

### func NewOf

```go
func NewOf[V any](opts ...OptionOf[V]) CacheOf[V]
```

### func NewOfDefault

```go
func NewOfDefault[V any](defaultExpiration, cleanupInterval time.Duration, evictedCallback ...EvictedCallbackOf[V]) CacheOf[V]
```

## type Config

```go
type Config struct {
    // DefaultExpiration default expiration time for key-value pairs.
    DefaultExpiration time.Duration

    // CleanupInterval the interval at which expired key-value pairs are automatically cleaned up.
    CleanupInterval time.Duration

    // EvictedCallback executed when the key-value pair expires.
    EvictedCallback EvictedCallback
}
```

### func DefaultConfig

```go
func DefaultConfig() Config
```

## type ConfigOf

```go
type ConfigOf[V any] struct {
    // DefaultExpiration default expiration time for key-value pairs.
    DefaultExpiration time.Duration

    // CleanupInterval the interval at which expired key-value pairs are automatically cleaned up.
    CleanupInterval time.Duration

    // EvictedCallback executed when the key-value pair expires.
    EvictedCallback EvictedCallbackOf[V]
}
```

### func DefaultConfigOf

```go
func DefaultConfigOf[V any]() ConfigOf[V]
```

## type EvictedCallback

EvictedCallback callback function to execute when the key\-value pair expires and is evicted\. Warning: cannot block\, it is recommended to use goroutine\.

```go
type EvictedCallback func(k string, v interface{})
```

## type EvictedCallbackOf

EvictedCallbackOf callback function to execute when the key\-value pair expires and is evicted\. Warning: cannot block\, it is recommended to use goroutine\.

```go
type EvictedCallbackOf[V any] func(k string, v V)
```

## type Map

```go
type Map interface {
    // Store add item to the cache, replacing any existing items.
    Store(k string, v interface{})

    // Load an item from the cache.
    // Returns the item or nil,
    // and a boolean indicating whether the key was found.
    Load(k string) (interface{}, bool)

    // LoadOrStore returns the existing value for the key if present.
    // Otherwise, it stores and returns the given value.
    // The loaded result is true if the value was loaded, false if stored.
    LoadOrStore(k string, v interface{}) (interface{}, bool)

    // LoadAndStore returns the existing value for the key if present,
    // while setting the new value for the key.
    // Otherwise, it stores and returns the given value.
    // The loaded result is true if the value was loaded, false otherwise.
    LoadAndStore(k string, v interface{}) (interface{}, bool)

    // LoadAndDelete Get an item from the cache, and delete the key.
    // Returns the item or nil,
    // and a boolean indicating whether the key was found.
    LoadAndDelete(k string) (interface{}, bool)

    // Delete an item from the cache.
    // Does nothing if the key is not in the cache.
    Delete(k string)

    // Range calls f sequentially for each key and value present in the map.
    // If f returns false, range stops the iteration.
    Range(f func(k string, v interface{}) bool)

    // Size returns the number of items in the cache.
    // This may include items that have expired but have not been cleaned up.
    Size() int
}
```

### func NewMap

```go
func NewMap() Map
```

NewMap the keys never expire\, similar to the use of sync\.Map\.

## type MapOf

```go
type MapOf[V any] interface {
    // Store add item to the cache, replacing any existing items.
    Store(k string, v V)

    // Load an item from the cache.
    // Returns the item or nil,
    // and a boolean indicating whether the key was found.
    Load(k string) (V, bool)

    // LoadOrStore returns the existing value for the key if present.
    // Otherwise, it stores and returns the given value.
    // The loaded result is true if the value was loaded, false if stored.
    LoadOrStore(k string, v V) (V, bool)

    // LoadAndStore returns the existing value for the key if present,
    // while setting the new value for the key.
    // Otherwise, it stores and returns the given value.
    // The loaded result is true if the value was loaded, false otherwise.
    LoadAndStore(k string, v V) (V, bool)

    // LoadAndDelete Get an item from the cache, and delete the key.
    // Returns the item or nil,
    // and a boolean indicating whether the key was found.
    LoadAndDelete(k string) (V, bool)

    // Delete an item from the cache.
    // Does nothing if the key is not in the cache.
    Delete(k string)

    // Range calls f sequentially for each key and value present in the map.
    // If f returns false, range stops the iteration.
    Range(f func(k string, v V) bool)

    // Size returns the number of items in the cache.
    // This may include items that have expired but have not been cleaned up.
    Size() int
}
```

### func NewMapOf

```go
func NewMapOf[V any]() MapOf[V]
```

NewMapOf the keys never expire\, similar to the use of sync\.Map\.

## type Option

```go
type Option func(config *Config)
```

### func WithCleanupInterval

```go
func WithCleanupInterval(interval time.Duration) Option
```

### func WithDefaultExpiration

```go
func WithDefaultExpiration(duration time.Duration) Option
```

### func WithEvictedCallback

```go
func WithEvictedCallback(ec EvictedCallback) Option
```

## type OptionOf

```go
type OptionOf[V any] func(config *ConfigOf[V])
```

### func WithCleanupIntervalOf

```go
func WithCleanupIntervalOf[V any](interval time.Duration) OptionOf[V]
```

### func WithDefaultExpirationOf

```go
func WithDefaultExpirationOf[V any](duration time.Duration) OptionOf[V]
```

### func WithEvictedCallbackOf

```go
func WithEvictedCallbackOf[V any](ec EvictedCallbackOf[V]) OptionOf[V]
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
