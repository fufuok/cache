<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# cache

```go
import "github.com/fufuok/cache"
```

## Index

- [Constants](<#constants>)
- [type Cache](<#Cache>)
  - [func New\[K comparable, V any\]\(opts ...Option\[K, V\]\) Cache\[K, V\]](<#New>)
  - [func NewDefault\[K comparable, V any\]\(defaultExpiration, cleanupInterval time.Duration, evictedCallback ...EvictedCallback\[K, V\]\) Cache\[K, V\]](<#NewDefault>)
- [type ComputeOp](<#ComputeOp>)
- [type Config](<#Config>)
  - [func DefaultConfig\[K comparable, V any\]\(\) Config\[K, V\]](<#DefaultConfig>)
- [type EvictedCallback](<#EvictedCallback>)
- [type ItemWithExpiration](<#ItemWithExpiration>)
- [type Map](<#Map>)
- [type Option](<#Option>)
  - [func WithCleanupInterval\[K comparable, V any\]\(interval time.Duration\) Option\[K, V\]](<#WithCleanupInterval>)
  - [func WithDefaultExpiration\[K comparable, V any\]\(duration time.Duration\) Option\[K, V\]](<#WithDefaultExpiration>)
  - [func WithEvictedCallback\[K comparable, V any\]\(ec EvictedCallback\[K, V\]\) Option\[K, V\]](<#WithEvictedCallback>)
  - [func WithMinCapacity\[K comparable, V any\]\(sizeHint int\) Option\[K, V\]](<#WithMinCapacity>)


## Constants

<a name="NoExpiration"></a>

```go
const (
    // NoExpiration mark cached item never expire.
    NoExpiration = -2 * time.Second

    // DefaultExpiration use the default expiration time set when the cache was created.
    // Equivalent to passing in the same e duration as was given to NewCache() or NewCacheDefault().
    DefaultExpiration = -1 * time.Second

    // DefaultCleanupInterval the default time interval for automatically cleaning up expired key-value pairs
    DefaultCleanupInterval = 10 * time.Second

    // DefaultMinCapacity specify the initial cache capacity (minimum capacity)
    DefaultMinCapacity = 32 * 3
)
```

<a name="Cache"></a>
## type [Cache](<https://github.com/fufuok/cache/blob/master/cache.go#L7-L151>)



```go
type Cache[K comparable, V any] interface {
    // Set add item to the cache, replacing any existing items.
    // (DefaultExpiration), the item uses a cached default expiration time.
    // (NoExpiration), the item never expires.
    // All values less than or equal to 0 are the same except DefaultExpiration,
    // which means never expires.
    Set(k K, v V, d time.Duration)

    // SetDefault add item to the cache with the default expiration time,
    // replacing any existing items.
    SetDefault(k K, v V)

    // SetForever add item to cache and set to never expire, replacing any existing items.
    SetForever(k K, v V)

    // Get an item from the cache.
    // Returns the item or nil,
    // and a boolean indicating whether the key was found.
    Get(k K) (value V, ok bool)

    // GetWithExpiration get an item from the cache.
    // Returns the item or nil,
    // along with the expiration time, and a boolean indicating whether the key was found.
    GetWithExpiration(k K) (value V, expiration time.Time, ok bool)

    // GetWithTTL get an item from the cache.
    // Returns the item or nil,
    // with the remaining lifetime and a boolean indicating whether the key was found.
    GetWithTTL(k K) (value V, ttl time.Duration, ok bool)

    // GetOrSet returns the existing value for the key if present.
    // Otherwise, it stores and returns the given value.
    // The loaded result is true if the value was loaded, false if stored.
    GetOrSet(k K, v V, d time.Duration) (value V, loaded bool)

    // GetAndSet returns the existing value for the key if present,
    // while setting the new value for the key.
    // Otherwise, it stores and returns the given value.
    // The loaded result is true if the value was loaded, false otherwise.
    GetAndSet(k K, v V, d time.Duration) (value V, loaded bool)

    // GetAndRefresh Get an item from the cache, and refresh the item's expiration time.
    // Returns the item or nil,
    // and a boolean indicating whether the key was found.
    GetAndRefresh(k K, d time.Duration) (value V, loaded bool)

    // GetOrCompute returns the existing value for the key if
    // present. Otherwise, it tries to compute the value using the
    // provided function and, if successful, stores and returns
    // the computed value. The loaded result is true if the value was
    // loaded, or false if computed. If valueFn returns true as the
    // cancel value, the computation is cancelled and the zero value
    // for type V is returned.
    //
    // This call locks a hash table bucket while the compute function
    // is executed. It means that modifications on other entries in
    // the bucket will be blocked until the valueFn executes. Consider
    // this when the function includes long-running operations.
    GetOrCompute(k K, valueFn func() (newValue V, cancel bool), d time.Duration) (value V, loaded bool)

    // Compute either sets the computed new value for the key,
    // deletes the value for the key, or does nothing, based on
    // the returned [ComputeOp]. When the op returned by valueFn
    // is [UpdateOp], the value is updated to the new value. If
    // it is [DeleteOp], the entry is removed from the map
    // altogether. And finally, if the op is [CancelOp] then the
    // entry is left as-is. In other words, if it did not already
    // exist, it is not created, and if it did exist, it is not
    // updated. This is useful to synchronously execute some
    // operation on the value without incurring the cost of
    // updating the map every time. The ok result indicates
    // whether the entry is present in the map after the compute
    // operation. The actual result contains the value of the map
    // if a corresponding entry is present, or the zero value
    // otherwise. See the example for a few use cases.
    //
    // This call locks a hash table bucket while the compute function
    // is executed. It means that modifications on other entries in
    // the bucket will be blocked until the valueFn executes. Consider
    // this when the function includes long-running operations.
    Compute(
        k K,
        valueFn func(oldValue V, loaded bool) (newValue V, op ComputeOp),
        d time.Duration,
    ) (actual V, ok bool)

    // GetAndDelete Get an item from the cache, and delete the key.
    // Returns the item or nil,
    // and a boolean indicating whether the key was found.
    GetAndDelete(k K) (value V, loaded bool)

    // Delete an item from the cache.
    // Does nothing if the key is not in the cache.
    Delete(k K)

    // DeleteExpired delete all expired items from the cache.
    DeleteExpired()

    // Range calls f sequentially for each key and value present in the map.
    // If f returns false, range stops the iteration.
    Range(f func(k K, v V) bool)

    // Items return the items in the cache.
    // This is a snapshot, which may include items that are about to expire.
    Items() map[K]V

    // ItemsWithExpiration return the items in the cache with their expiration times.
    // This is a snapshot, which may include items that are about to expire.
    // The returned map contains items where the time.Time is zero for items that never expire.
    ItemsWithExpiration() map[K]ItemWithExpiration[V]

    // LoadItems loads multiple items into the cache.
    // This is useful for bulk loading data from external sources.
    LoadItems(items map[K]V, defaultExpiration time.Duration)

    // LoadItemsWithExpiration loads multiple items with their expiration times into the cache.
    // Items with zero expiration time will never expire.
    LoadItemsWithExpiration(items map[K]ItemWithExpiration[V])

    // Clear deletes all keys and values currently stored in the map.
    Clear()

    // Close closes the cache and releases any resources associated with it.
    Close()

    // Count returns the number of items in the cache.
    // This may include items that have expired but have not been cleaned up.
    Count() int

    // DefaultExpiration returns the default expiration time for the cache.
    DefaultExpiration() time.Duration

    // SetDefaultExpiration sets the default expiration time for the cache.
    // Atomic safety.
    SetDefaultExpiration(defaultExpiration time.Duration)

    // EvictedCallback returns the callback function to execute
    // when a key-value pair expires and is evicted.
    EvictedCallback() EvictedCallback[K, V]

    // SetEvictedCallback Set the callback function to be executed
    // when the key-value pair expires and is evicted.
    // Atomic safety.
    SetEvictedCallback(evictedCallback EvictedCallback[K, V])
}
```

<a name="New"></a>
### func [New](<https://github.com/fufuok/cache/blob/master/cache.go#L160>)

```go
func New[K comparable, V any](opts ...Option[K, V]) Cache[K, V]
```



<a name="NewDefault"></a>
### func [NewDefault](<https://github.com/fufuok/cache/blob/master/cache.go#L168-L172>)

```go
func NewDefault[K comparable, V any](defaultExpiration, cleanupInterval time.Duration, evictedCallback ...EvictedCallback[K, V]) Cache[K, V]
```



<a name="ComputeOp"></a>
## type [ComputeOp](<https://github.com/fufuok/cache/blob/master/map.go#L7>)



```go
type ComputeOp = xsync.ComputeOp
```

<a name="CancelOp"></a>

```go
const (
    // CancelOp signals to Compute to not do anything as a result
    // of executing the lambda. If the entry was not present in
    // the map, nothing happens, and if it was present, the
    // returned value is ignored.
    CancelOp ComputeOp = iota
    // UpdateOp signals to Compute to update the entry to the
    // value returned by the lambda, creating it if necessary.
    UpdateOp
    // DeleteOp signals to Compute to always delete the entry
    // from the map.
    DeleteOp
)
```

<a name="Config"></a>
## type [Config](<https://github.com/fufuok/cache/blob/master/config.go#L26-L38>)



```go
type Config[K comparable, V any] struct {
    // DefaultExpiration default expiration time for key-value pairs.
    DefaultExpiration time.Duration

    // CleanupInterval the interval at which expired key-value pairs are automatically cleaned up.
    CleanupInterval time.Duration

    // EvictedCallback executed when the key-value pair expires.
    EvictedCallback EvictedCallback[K, V]

    // MinCapacity specify the initial cache capacity (minimum capacity)
    MinCapacity int
}
```

<a name="DefaultConfig"></a>
### func [DefaultConfig](<https://github.com/fufuok/cache/blob/master/config.go#L40>)

```go
func DefaultConfig[K comparable, V any]() Config[K, V]
```



<a name="EvictedCallback"></a>
## type [EvictedCallback](<https://github.com/fufuok/cache/blob/master/config.go#L24>)

EvictedCallback callback function to execute when the key\-value pair expires and is evicted. Warning: cannot block, it is recommended to use goroutine.

```go
type EvictedCallback[K comparable, V any] func(k K, v V)
```

<a name="ItemWithExpiration"></a>
## type [ItemWithExpiration](<https://github.com/fufuok/cache/blob/master/cache.go#L155-L158>)

ItemWithExpiration represents a cache item with its expiration time Zero time means never expires

```go
type ItemWithExpiration[V any] struct {
    Value      V         `json:"value"`
    Expiration time.Time `json:"expiration"`
}
```

<a name="Map"></a>
## type [Map](<https://github.com/fufuok/cache/blob/master/map.go#L23-L114>)



```go
type Map[K comparable, V any] interface {
    // Load returns the value stored in the map for a key, or zero value
    // of type V if no value is present.
    // The ok result indicates whether value was found in the map.
    Load(key K) (value V, ok bool)

    // Store sets the value for a key.
    Store(key K, value V)

    // LoadOrStore returns the existing value for the key if present.
    // Otherwise, it stores and returns the given value.
    // The loaded result is true if the value was loaded, false if stored.
    LoadOrStore(key K, value V) (actual V, loaded bool)

    // LoadAndStore returns the existing value for the key if present,
    // while setting the new value for the key.
    // It stores the new value and returns the existing one, if present.
    // The loaded result is true if the existing value was loaded,
    // false otherwise.
    LoadAndStore(key K, value V) (actual V, loaded bool)

    // LoadOrCompute returns the existing value for the key if
    // present. Otherwise, it tries to compute the value using the
    // provided function and, if successful, stores and returns
    // the computed value. The loaded result is true if the value was
    // loaded, or false if computed. If valueFn returns true as the
    // cancel value, the computation is cancelled and the zero value
    // for type V is returned.
    //
    // This call locks a hash table bucket while the compute function
    // is executed. It means that modifications on other entries in
    // the bucket will be blocked until the valueFn executes. Consider
    // this when the function includes long-running operations.
    LoadOrCompute(
        key K,
        valueFn func() (newValue V, cancel bool),
    ) (value V, loaded bool)

    // Compute either sets the computed new value for the key,
    // deletes the value for the key, or does nothing, based on
    // the returned [ComputeOp]. When the op returned by valueFn
    // is [UpdateOp], the value is updated to the new value. If
    // it is [DeleteOp], the entry is removed from the map
    // altogether. And finally, if the op is [CancelOp] then the
    // entry is left as-is. In other words, if it did not already
    // exist, it is not created, and if it did exist, it is not
    // updated. This is useful to synchronously execute some
    // operation on the value without incurring the cost of
    // updating the map every time. The ok result indicates
    // whether the entry is present in the map after the compute
    // operation. The actual result contains the value of the map
    // if a corresponding entry is present, or the zero value
    // otherwise. See the example for a few use cases.
    //
    // This call locks a hash table bucket while the compute function
    // is executed. It means that modifications on other entries in
    // the bucket will be blocked until the valueFn executes. Consider
    // this when the function includes long-running operations.
    Compute(
        key K,
        valueFn func(oldValue V, loaded bool) (newValue V, op ComputeOp),
    ) (actual V, ok bool)

    // LoadAndDelete deletes the value for a key, returning the previous
    // value if any. The loaded result reports whether the key was
    // present.
    LoadAndDelete(key K) (value V, loaded bool)

    // Delete deletes the value for a key.
    Delete(key K)

    // Range calls f sequentially for each key and value present in the
    // map. If f returns false, range stops the iteration.
    //
    // Range does not necessarily correspond to any consistent snapshot
    // of the Map's contents: no key will be visited more than once, but
    // if the value for any key is stored or deleted concurrently, Range
    // may reflect any mapping for that key from any point during the
    // Range call.
    //
    // It is safe to modify the map while iterating it, including entry
    // creation, modification and deletion. However, the concurrent
    // modification rule apply, i.e. the changes may be not reflected
    // in the subsequently iterated entries.
    Range(f func(key K, value V) bool)

    // Clear deletes all keys and values currently stored in the map.
    Clear()

    // Size returns current size of the map.
    Size() int
}
```

<a name="Option"></a>
## type [Option](<https://github.com/fufuok/cache/blob/master/options.go#L7>)



```go
type Option[K comparable, V any] func(config *Config[K, V])
```

<a name="WithCleanupInterval"></a>
### func [WithCleanupInterval](<https://github.com/fufuok/cache/blob/master/options.go#L15>)

```go
func WithCleanupInterval[K comparable, V any](interval time.Duration) Option[K, V]
```



<a name="WithDefaultExpiration"></a>
### func [WithDefaultExpiration](<https://github.com/fufuok/cache/blob/master/options.go#L9>)

```go
func WithDefaultExpiration[K comparable, V any](duration time.Duration) Option[K, V]
```



<a name="WithEvictedCallback"></a>
### func [WithEvictedCallback](<https://github.com/fufuok/cache/blob/master/options.go#L21>)

```go
func WithEvictedCallback[K comparable, V any](ec EvictedCallback[K, V]) Option[K, V]
```



<a name="WithMinCapacity"></a>
### func [WithMinCapacity](<https://github.com/fufuok/cache/blob/master/options.go#L27>)

```go
func WithMinCapacity[K comparable, V any](sizeHint int) Option[K, V]
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
